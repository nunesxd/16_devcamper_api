Como o projeto foi iniciado anteriormente, sem antes termos documentado os procedimentos adotados por etapa, acreditamos ser interessante iniciar pelos comandos utilizados para que o projeto funcione como está, ou seja, a sua estrutura básica para o funcionamento.

Para o funcionamento do projeto, precisamos minimamente instalar os seguintes softwares: Mongodb Community Edition (base de dados em sí), Mongodb Compass (IDE para melhor interface com o banco), NodeJS (assim como as bibliotecas dependentes, como express, etc.), GIT. Também usamos o postman, que é um software para facilitar o envio e recebimento de dados via HTTP, para testar a ferramenta.

Para criar um projeto no NodeJS usamos o comando abaixo, com isso criamos o 'package.json' e o 'package-lock.json':
-- npm init
. OBS: 'package-lock.json' Dentre outros, é onde fica as dependencias do projeto, assim como o local de cada um.
. OBS 2: 'package.json' Dentre outros, é onde fica as configurações do projeto, como o principal arquivo do projeto (no caso o 'server.js'), e onde podemos colocar os scripts, como o que fizemos, o 'dev', que nos permite executar o site em ambiente de desenvolvimento. O comando de execução do script é:
-- npm run dev

No 'server.js', iremos trazer todos os módulos que desenvolvemos ao longo do projeto, carregá-los devidamente e inicar o site. É importante salientar que a ordem do carregamento dos módulos é importante, alguns módulos dependem de outros para funcionar.

Para que estes módulos sejam utilizados, eles precisam conter o trecho abaixo no final do módulo, exportando a funcionalidade que será importada nos demais módulos:
-- module.exports = [constante/variável criada];
O 'module.exports' é próprio do NodeJS.

Criamos a pasta 'config' e nela criamos o 'config.env', este arquivo será local por segurança e inserido no gitignore, ele irá conter as variáveis do ambiente, que serão usados nos demais módulos, através do código:
-- process.env.[variável do ambiente]
Criamos também o 'db.js', que contém os dados de conexão do banco de dados, utilizando o 'mongoose'.

No módulo 'db.js', como o connect do mongoose retorna uma promise, poderíamos usar o '.then()', mas com a estratégia que usamos (usando async), podemos pedir para o Node esperar o retorno do connect, evitando problemas de conexão (que no caso não deveriam acontecer muito, pois o banco será local).
Um outro problema que teríamos, seria em lidar com Unhandled errors das promises, poderíamos usar um try/catch no processo, mas optamos por lidar com os erros no 'server.js'.

Cabe mencionar que utilizamos uma dos seus melhores recursos, que é a execução assincrona, ou seja, criação de uma 'promisse', que irá retornar o valor processado quando este estiver pronto, sem impactar na execução do código.
-- const [constante/variavel] = async () => {}
Dentro da função devemos usar o 'await':
-- const conn = await mongoose.connect(process.env.MONGO_URI, { }

Nos módulos presentes nos 'controllers', que contém os métodos CRUD de nossa API, utilizamos um conceito de versionamento (v1, v2, dentro da URL), que possibilita continuar usando as versões anteriores simultâneamente.
. OBS: Anteriormente, fizemos um 'try/catch' dentro das funções CRUD async, mas identificamos que utilizando o método 'asyncHandler', do módulo 'async.js', podemos aproveitar o 'catch()' das Promises criadas, retirando assim possíveis repetições.

A próxima pasta que criamos é a 'routes', que contém todas as rotas, urls de nosso site. Importamos também os métodos 'CRUD', presentes na pasta 'controllers', para associá-los as rotas definidas.
Uma outra estratégia que utilizamos foi a de importar as rotas referentes ao outro modelo, uma espécie de 're-roteamento':
-- const [contante / variavel de roteamento] = require('./[roteamento do modelo]');
-- router.use('/:[parâmetro do outro modelo]/[url ou rota deste modelo]', [contante / variavel de roteamento]);

Como estamos utilizando re-roteamento, devemos adicionar uma configuração a variável criada no modelo que irá receber o roteamento:
-- const [variavel / constante] = express.Router({ mergeParams: true });

Podemos utilizar o 'router' do 'express' de diversas formas, como:
-- router.get('/', (req, res) => {}); (ou '.post()')
Usamos os parâmetros como em outras linguagens
-- router.route('/[url ou rota]/:[parâmetro1]/:[parâmetro2]').get([método CRUD de GET]);

. OBS: Por padrão, o 'express' nos permite passar um erro pelo 'next()', nos enviando um html contendo o erro. Podemos utilizar o mesmo princípio, mas alterando o 'handling' (para isso criamos o arquivo de 'erro' na pasta de middlewares, e uma extensão da classe na pasta utils, 'error.js').
Uma das outras formas de se lidar com o erro, é criando um novo objeto de erro, como abaixo:
next(new ErrorHandler(`Não foi possível identificar o Bootcamp de ID num: ${req.params.id}`, 404));
Usando o 'catch' apenas, poderíamos escrever:
next(err);

No curso vemos o uso da biblioteca 'morgan', que nos disponibiliza um log mais completo do processamento de nosso projeto, além disso, também nos permite modificar a cor e estilo dos textos que nos são apresentados no log do servidor, como erro vermelho e em itálico por exemplo, mas optamos por não utilizar a mudança de cores do texto no projeto, apenas a parte de log.

Posteriormente criamos a pasta que contém os 'middlewares', que são os módulos responsáveis por alterar os dados durante o processamento (por isso que 'middle'). 
O módulo 'async' faz o que já mencionamos anteriormente, nos permite executar o código de forma assincrona e retornar uma promisse.
O 'error.js' é uma forma de erro customizada, que é alterada de acordo com os erros que ocorreram durante o processamento.
Já o 'logger.js' é um módulo de log criado apenas para testes, neste projeto iremos utilizar o 'morgan' para isso.
É importante ressaltar que o servidor irá utilizar o middleware apenas se utilizarmos:
-- app.use([middleware])
. OBS: Lembrando que o 'app' é um objeto do express.

Existe um outro tipo de 'middleware', que pode ser chamado antes e / ou depois de um modelo / schema for salvo, atualizado no banco de dados, exemplos:

-- BootcampSchema.pre('remove', async function (next) {});
- O 'pre()' é uma chamada que será executada antes que o comando 'remove' seja executado no BD para aquele modelo, e como em todos os middlewares, passamos o 'next' também (apontando para seguir para a próxima rota, e / ou middleware). Assim como o pre temos o 'post()', que possui a lógica similar, mas é executado no momento momento do post.

-- BootcampSchema.virtual('courses', {});
- Já o 'virtuals()' é um 'populate reverso', isso é interessante quando temos uma tabela linkada a outra, pois quando, no caso, o bootcamp for atualizado, ele irá gerar uma lista com os dados dos seus respectivos courses.

O schema do Mongoose também possui algumas funções próprias, como:
1) O 'aggregate', que retorna uma promisse, recebe um pipeline '[]', que nada mais é que uma sequência de comandos que deve ser seguida (Exemplo no modelo 'Course.js'), e que no fim nos gera um objeto segundo essa sequência de comandos executada no BD;
2) O 'constructor', como nas demais linguagens, nos permite executar algo no momento da criação do objeto, de sua inicialização. (Exemplo no modelo 'Course.js');

Nos métodos CRUD presentes no 'controllers.js', podemos disponibilizar 'queries' dentro da nossa URL (devemos começar a query por '?', separando os campos com '&'), para que o mongoose use no 'find()', procurando os registros dentro da base de dados.
Cabe mencionar, que estas queries precisam de uma "tradução" para serem usadas pelo JSON, por exemplo, devemos inserir o caractere '$' em casos de "menor do que X valor", pois o mongoose não realiza tal procedimento, e considera que o valor informado é uma ID, causando erro.
. OBS: Para mais detalhes quanto ao uso de Query, ver módulo 'middlewares' > 'advancedResults.js'.
Para os casos como o 'select' e 'sort', como estes não são campos do schema, devemos retirá-los da query principal (que apenas realiza os matches por campo), eles seriam separados, e incindiriam nos bootcamps encontrados pelo GET. Caso não tenha um 'select' e 'sort' na URL, o 'GET' funcionaria normalmente.

Colocamos as 'queries' em um módulo middleware para facilitar o seu uso em demais métodos, do jeito que foi feito, optamos por executar o middleware através do módulo de roteamento, utilizando o objeto 'res.advancedResults' para obtenção dos resultados nos métodos presentes nos 'controllers'.

As 'Queries' que foram criadas são as seguintes (lembrando que devemos ter o '?' no começo, e '&' para separar as queries):
1) [campo do modelo]=[valor]
- Retorna os registros que possuem o respectivo valor no campo informado;
2) select=[campo 1 do modelo],[campo 2 do modelo],[...]
- Retorna todos os registros encontrados anteriormente, mas contendo apenas os campos selecionados;
3) limit=[int]
- Limita a quantidade de registros que aparece no resultado;
4) page=[int]
- Retorna os registros encontrados anteriormente, mas na segunda segunda página da paginação criada;

O Mongoose aceita alguns comandos para podermos identificar alguns dados em nosso banco, exemplos:
-- $match: {bootcamp: bootcampId}
Feito no modelo do 'Course.js'. O match irá procurar a igualdade entre o campo que está no schema 'bootcamp' e o id que foi informado no chamar do método estático, 'bootcampId'.
. OBS: Em diversas ocasiões, o Mongoose utiliza o caractere '$' para identificar e executar um comando, em alguns casos precisamos adicionar o '$' para que o Mongoose execute o comando adequadamente.

Para podermos lidar com os modelos criados pelo Mongoose podemos usar, sendo todos os métodos assincronos também:
1) [model].findById(req.params.[id])
- que traz todos os dados identificados no banco pelo id especificado;
2) [model].findByIdAndUpdate(req.params.[id], req.body, {
    new: true,
    runValidators: true});
- Nos permite atualizar os dados daquele item, pelo corpo que foi enviado na requisição HTTP de 'PUT' enviada. O terceiro parâmetro são as configurações, no caso, 'new' para que sejam retornados os dados atualizados, e o 'runvalidator' para que sejam executadas as validações nos dados que foram enviados no body da requisição; 
3) [model].findByIdAndDelete(req.params.[id]); ou [model].remove();
- Fazem a mesma coisa, que é excluir aquele item que foi identificado pelo id, no BD;
4) Course.findById(req.params.id).populate({
    path: 'bootcamp',
    select: 'name description'
});
- O 'populate', nos permite trazer as informações do BD referentes a tabela que queremos, considerando que elas tenham a ligação por chave primária. No exemplo acima, foi possível trazer os dados do bootcamp através do modelo de cursos, uma vez que os dois possuem ligação (Exemplo no middleware 'advancedResults.js');
. OBS: Cabe mencionar que o populate pode ser simples, especificando apenas o modelo, como 'bootcamp', ou se quisermos algo mais específico, devemos passar um objeto, como no exemplo acima.
5) [model].find()
- Procura os registros com o que for informado, podemos criar uma query e passar para o find, por exemplo;

Instalamos o app 'express-fileupload'. Criamos no 'controllers' > 'bootcamps' a funcionlidade de upload de fotos para o bootcamp que for informado. Em seguida criamos a respectiva rota para a funcionalidade, testando por fim no Postman.
Configuramos o body no Postman como 'form-data', criamos o campo 'file', com o tipo 'file', e selecionamos a imagem para enviar ao servidor.
. OBS: Assim como em outros middlewares, é importante que inicializemos o app 'fileupload' antes da criação das rotas, no módulo 'server.js', se não sempre teremos o erro de envio de fotos.
Em nosso arquivo de 'enviroment', criamos o local onde o arquivo deve ser armazenado.

Durante a configuração do middleware de upload de arquivos, renomeamos o arquivo enviado com um nome customizado, para evitar sobrescrita de arquivos, que por ventura tenham o mesmo nome no diretório do servidor destino.
Para assegurar que a extensão do arquivo seja parte do seu nome, usamos a biblioteca nativa do NodeJS 'path', exemplo de um dos métodos:
-- path.parse(file.name).ext

Para executarmos a função de upload da imagem, podemos usar o método builtin 'mv':
-- file.mv(`${process.env.FILE_PATH_UPLOAD}/${file.name}`, [callback para armazenar o arquivo]);
Criamos a pasta onde configuramos no enviroment, e definimos a pasta como sendo o local de arquivos estáticos, dentro do módulo 'server.js', usamos o path para concatenar a raiz da pasta do projeto:
-- app.use(express.static(path.join(__dirname, 'public')));

